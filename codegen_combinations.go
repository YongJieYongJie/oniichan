// Code generated by codegen.go DO NOT EDIT.
// Version: 0.0.0
// Checksum: 12717551177061361695

package oniichan

import (
	"github.com/YongJieYongJie/tttuples/atuple"
)

// Combinations2 is the 2-element version of Combinations.
func Combinations2[T any](in <-chan T) <-chan atuple.Packed2[T, T] {
	out := make(chan atuple.Packed2[T, T])
	go func() {
		defer close(out)
		combiLen := 2
		s := Slice(in)
		n := len(s)
		if n < combiLen {
			panic("invalid argument to Combinations: size of in must greater than or equal to 2")
		}
		indices := Slice(Range(combiLen))
		out <- atuple.Pack2(s[indices[0]], s[indices[1]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (i + n - combiLen).
			for i = combiLen - 1; i >= 0 && indices[i] == i+n-combiLen; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// move back to the right setting each index to its lowest possible value
			// (one higher than the index to its left -- this maintains the sort
			// order invariant).
			indices[i]++
			for j := i + 1; j < combiLen; j++ {
				indices[j] = indices[j-1] + 1
			}

			out <- atuple.Pack2(s[indices[0]], s[indices[1]])
		}
	}()
	return out
}

// Combinations3 is the 3-element version of Combinations.
func Combinations3[T any](in <-chan T) <-chan atuple.Packed3[T, T, T] {
	out := make(chan atuple.Packed3[T, T, T])
	go func() {
		defer close(out)
		combiLen := 3
		s := Slice(in)
		n := len(s)
		if n < combiLen {
			panic("invalid argument to Combinations: size of in must greater than or equal to 3")
		}
		indices := Slice(Range(combiLen))
		out <- atuple.Pack3(s[indices[0]], s[indices[1]], s[indices[2]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (i + n - combiLen).
			for i = combiLen - 1; i >= 0 && indices[i] == i+n-combiLen; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// move back to the right setting each index to its lowest possible value
			// (one higher than the index to its left -- this maintains the sort
			// order invariant).
			indices[i]++
			for j := i + 1; j < combiLen; j++ {
				indices[j] = indices[j-1] + 1
			}

			out <- atuple.Pack3(s[indices[0]], s[indices[1]], s[indices[2]])
		}
	}()
	return out
}

// Combinations4 is the 4-element version of Combinations.
func Combinations4[T any](in <-chan T) <-chan atuple.Packed4[T, T, T, T] {
	out := make(chan atuple.Packed4[T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 4
		s := Slice(in)
		n := len(s)
		if n < combiLen {
			panic("invalid argument to Combinations: size of in must greater than or equal to 4")
		}
		indices := Slice(Range(combiLen))
		out <- atuple.Pack4(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (i + n - combiLen).
			for i = combiLen - 1; i >= 0 && indices[i] == i+n-combiLen; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// move back to the right setting each index to its lowest possible value
			// (one higher than the index to its left -- this maintains the sort
			// order invariant).
			indices[i]++
			for j := i + 1; j < combiLen; j++ {
				indices[j] = indices[j-1] + 1
			}

			out <- atuple.Pack4(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]])
		}
	}()
	return out
}

// Combinations5 is the 5-element version of Combinations.
func Combinations5[T any](in <-chan T) <-chan atuple.Packed5[T, T, T, T, T] {
	out := make(chan atuple.Packed5[T, T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 5
		s := Slice(in)
		n := len(s)
		if n < combiLen {
			panic("invalid argument to Combinations: size of in must greater than or equal to 5")
		}
		indices := Slice(Range(combiLen))
		out <- atuple.Pack5(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (i + n - combiLen).
			for i = combiLen - 1; i >= 0 && indices[i] == i+n-combiLen; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// move back to the right setting each index to its lowest possible value
			// (one higher than the index to its left -- this maintains the sort
			// order invariant).
			indices[i]++
			for j := i + 1; j < combiLen; j++ {
				indices[j] = indices[j-1] + 1
			}

			out <- atuple.Pack5(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]])
		}
	}()
	return out
}

// Combinations6 is the 6-element version of Combinations.
func Combinations6[T any](in <-chan T) <-chan atuple.Packed6[T, T, T, T, T, T] {
	out := make(chan atuple.Packed6[T, T, T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 6
		s := Slice(in)
		n := len(s)
		if n < combiLen {
			panic("invalid argument to Combinations: size of in must greater than or equal to 6")
		}
		indices := Slice(Range(combiLen))
		out <- atuple.Pack6(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (i + n - combiLen).
			for i = combiLen - 1; i >= 0 && indices[i] == i+n-combiLen; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// move back to the right setting each index to its lowest possible value
			// (one higher than the index to its left -- this maintains the sort
			// order invariant).
			indices[i]++
			for j := i + 1; j < combiLen; j++ {
				indices[j] = indices[j-1] + 1
			}

			out <- atuple.Pack6(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]])
		}
	}()
	return out
}

// Combinations7 is the 7-element version of Combinations.
func Combinations7[T any](in <-chan T) <-chan atuple.Packed7[T, T, T, T, T, T, T] {
	out := make(chan atuple.Packed7[T, T, T, T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 7
		s := Slice(in)
		n := len(s)
		if n < combiLen {
			panic("invalid argument to Combinations: size of in must greater than or equal to 7")
		}
		indices := Slice(Range(combiLen))
		out <- atuple.Pack7(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]], s[indices[6]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (i + n - combiLen).
			for i = combiLen - 1; i >= 0 && indices[i] == i+n-combiLen; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// move back to the right setting each index to its lowest possible value
			// (one higher than the index to its left -- this maintains the sort
			// order invariant).
			indices[i]++
			for j := i + 1; j < combiLen; j++ {
				indices[j] = indices[j-1] + 1
			}

			out <- atuple.Pack7(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]], s[indices[6]])
		}
	}()
	return out
}
