// Code generated by codegen.go DO NOT EDIT.
// Version: 0.0.0
// Checksum: 9088665384579260908

package oniichan

import (
	"github.com/YongJieYongJie/tttuples/atuple"
)

func Zip2[T1, T2 any](in1 <-chan T1, in2 <-chan T2) <-chan atuple.Packed2[T1, T2] {
	out := make(chan atuple.Packed2[T1, T2])
	go func() {
		defer close(out)
		for {
			
			e1, has := Next(in1)
			if !has {
				return
			}
			
			e2, has := Next(in2)
			if !has {
				return
			}
			
			out <- atuple.Pack2(e1, e2)
		}
	}()
	return out
}

func Zip3[T1, T2, T3 any](in1 <-chan T1, in2 <-chan T2, in3 <-chan T3) <-chan atuple.Packed3[T1, T2, T3] {
	out := make(chan atuple.Packed3[T1, T2, T3])
	go func() {
		defer close(out)
		for {
			
			e1, has := Next(in1)
			if !has {
				return
			}
			
			e2, has := Next(in2)
			if !has {
				return
			}
			
			e3, has := Next(in3)
			if !has {
				return
			}
			
			out <- atuple.Pack3(e1, e2, e3)
		}
	}()
	return out
}

func Zip4[T1, T2, T3, T4 any](in1 <-chan T1, in2 <-chan T2, in3 <-chan T3, in4 <-chan T4) <-chan atuple.Packed4[T1, T2, T3, T4] {
	out := make(chan atuple.Packed4[T1, T2, T3, T4])
	go func() {
		defer close(out)
		for {
			
			e1, has := Next(in1)
			if !has {
				return
			}
			
			e2, has := Next(in2)
			if !has {
				return
			}
			
			e3, has := Next(in3)
			if !has {
				return
			}
			
			e4, has := Next(in4)
			if !has {
				return
			}
			
			out <- atuple.Pack4(e1, e2, e3, e4)
		}
	}()
	return out
}

func Zip5[T1, T2, T3, T4, T5 any](in1 <-chan T1, in2 <-chan T2, in3 <-chan T3, in4 <-chan T4, in5 <-chan T5) <-chan atuple.Packed5[T1, T2, T3, T4, T5] {
	out := make(chan atuple.Packed5[T1, T2, T3, T4, T5])
	go func() {
		defer close(out)
		for {
			
			e1, has := Next(in1)
			if !has {
				return
			}
			
			e2, has := Next(in2)
			if !has {
				return
			}
			
			e3, has := Next(in3)
			if !has {
				return
			}
			
			e4, has := Next(in4)
			if !has {
				return
			}
			
			e5, has := Next(in5)
			if !has {
				return
			}
			
			out <- atuple.Pack5(e1, e2, e3, e4, e5)
		}
	}()
	return out
}

func Zip6[T1, T2, T3, T4, T5, T6 any](in1 <-chan T1, in2 <-chan T2, in3 <-chan T3, in4 <-chan T4, in5 <-chan T5, in6 <-chan T6) <-chan atuple.Packed6[T1, T2, T3, T4, T5, T6] {
	out := make(chan atuple.Packed6[T1, T2, T3, T4, T5, T6])
	go func() {
		defer close(out)
		for {
			
			e1, has := Next(in1)
			if !has {
				return
			}
			
			e2, has := Next(in2)
			if !has {
				return
			}
			
			e3, has := Next(in3)
			if !has {
				return
			}
			
			e4, has := Next(in4)
			if !has {
				return
			}
			
			e5, has := Next(in5)
			if !has {
				return
			}
			
			e6, has := Next(in6)
			if !has {
				return
			}
			
			out <- atuple.Pack6(e1, e2, e3, e4, e5, e6)
		}
	}()
	return out
}

func Zip7[T1, T2, T3, T4, T5, T6, T7 any](in1 <-chan T1, in2 <-chan T2, in3 <-chan T3, in4 <-chan T4, in5 <-chan T5, in6 <-chan T6, in7 <-chan T7) <-chan atuple.Packed7[T1, T2, T3, T4, T5, T6, T7] {
	out := make(chan atuple.Packed7[T1, T2, T3, T4, T5, T6, T7])
	go func() {
		defer close(out)
		for {
			
			e1, has := Next(in1)
			if !has {
				return
			}
			
			e2, has := Next(in2)
			if !has {
				return
			}
			
			e3, has := Next(in3)
			if !has {
				return
			}
			
			e4, has := Next(in4)
			if !has {
				return
			}
			
			e5, has := Next(in5)
			if !has {
				return
			}
			
			e6, has := Next(in6)
			if !has {
				return
			}
			
			e7, has := Next(in7)
			if !has {
				return
			}
			
			out <- atuple.Pack7(e1, e2, e3, e4, e5, e6, e7)
		}
	}()
	return out
}
