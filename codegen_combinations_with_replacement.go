// Code generated by codegen.go DO NOT EDIT.
// Version: 0.0.0
// Checksum: 1644679126901499091

package oniichan

import (
	"github.com/YongJieYongJie/tttuples/atuple"
)

// CombinationsWithReplacement2 is the 2-element version of CombinationsWithReplacement.
func CombinationsWithReplacement2[T any](in <-chan T) <-chan atuple.Packed2[T, T] {
	out := make(chan atuple.Packed2[T, T])
	go func() {
		defer close(out)
		combiLen := 2
		s := Slice(in)
		n := len(s)
		indices := []int{0, 0}
		out <- atuple.Pack2(s[indices[0]], s[indices[1]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (n-1).
			for i = combiLen - 1; i >= 0 && indices[i] == n-1; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// set all to the right to the same value.
			indices[i]++
			elem := indices[i]
			for j := i + 1; j < combiLen; j++ {
				indices[j] = elem
			}

			out <- atuple.Pack2(s[indices[0]], s[indices[1]])
		}
	}()
	return out
}

// CombinationsWithReplacement3 is the 3-element version of CombinationsWithReplacement.
func CombinationsWithReplacement3[T any](in <-chan T) <-chan atuple.Packed3[T, T, T] {
	out := make(chan atuple.Packed3[T, T, T])
	go func() {
		defer close(out)
		combiLen := 3
		s := Slice(in)
		n := len(s)
		indices := []int{0, 0}
		out <- atuple.Pack3(s[indices[0]], s[indices[1]], s[indices[2]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (n-1).
			for i = combiLen - 1; i >= 0 && indices[i] == n-1; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// set all to the right to the same value.
			indices[i]++
			elem := indices[i]
			for j := i + 1; j < combiLen; j++ {
				indices[j] = elem
			}

			out <- atuple.Pack3(s[indices[0]], s[indices[1]], s[indices[2]])
		}
	}()
	return out
}

// CombinationsWithReplacement4 is the 4-element version of CombinationsWithReplacement.
func CombinationsWithReplacement4[T any](in <-chan T) <-chan atuple.Packed4[T, T, T, T] {
	out := make(chan atuple.Packed4[T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 4
		s := Slice(in)
		n := len(s)
		indices := []int{0, 0}
		out <- atuple.Pack4(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (n-1).
			for i = combiLen - 1; i >= 0 && indices[i] == n-1; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// set all to the right to the same value.
			indices[i]++
			elem := indices[i]
			for j := i + 1; j < combiLen; j++ {
				indices[j] = elem
			}

			out <- atuple.Pack4(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]])
		}
	}()
	return out
}

// CombinationsWithReplacement5 is the 5-element version of CombinationsWithReplacement.
func CombinationsWithReplacement5[T any](in <-chan T) <-chan atuple.Packed5[T, T, T, T, T] {
	out := make(chan atuple.Packed5[T, T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 5
		s := Slice(in)
		n := len(s)
		indices := []int{0, 0}
		out <- atuple.Pack5(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (n-1).
			for i = combiLen - 1; i >= 0 && indices[i] == n-1; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// set all to the right to the same value.
			indices[i]++
			elem := indices[i]
			for j := i + 1; j < combiLen; j++ {
				indices[j] = elem
			}

			out <- atuple.Pack5(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]])
		}
	}()
	return out
}

// CombinationsWithReplacement6 is the 6-element version of CombinationsWithReplacement.
func CombinationsWithReplacement6[T any](in <-chan T) <-chan atuple.Packed6[T, T, T, T, T, T] {
	out := make(chan atuple.Packed6[T, T, T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 6
		s := Slice(in)
		n := len(s)
		indices := []int{0, 0}
		out <- atuple.Pack6(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (n-1).
			for i = combiLen - 1; i >= 0 && indices[i] == n-1; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// set all to the right to the same value.
			indices[i]++
			elem := indices[i]
			for j := i + 1; j < combiLen; j++ {
				indices[j] = elem
			}

			out <- atuple.Pack6(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]])
		}
	}()
	return out
}

// CombinationsWithReplacement7 is the 7-element version of CombinationsWithReplacement.
func CombinationsWithReplacement7[T any](in <-chan T) <-chan atuple.Packed7[T, T, T, T, T, T, T] {
	out := make(chan atuple.Packed7[T, T, T, T, T, T, T])
	go func() {
		defer close(out)
		combiLen := 7
		s := Slice(in)
		n := len(s)
		indices := []int{0, 0}
		out <- atuple.Pack7(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]], s[indices[6]])

		for {
			var i int
			// Scan indices right-to-left until finding one that is not at its
			// maximum (n-1).
			for i = combiLen - 1; i >= 0 && indices[i] == n-1; i-- {
			}

			// If i is negative, then the indices are all at their maximum value and
			// we're done.
			if i < 0 {
				return
			}

			// Increment the current index which we know is not at its maximum. Then
			// set all to the right to the same value.
			indices[i]++
			elem := indices[i]
			for j := i + 1; j < combiLen; j++ {
				indices[j] = elem
			}

			out <- atuple.Pack7(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]], s[indices[6]])
		}
	}()
	return out
}
