// Code generated by codegen.go DO NOT EDIT.
// Version: 0.0.0
// Checksum: 12153532965545950829

package oniichan

import (
	"github.com/YongJieYongJie/tttuples/atuple"
)

// Permutations2 is the 2-element version of Permutations.
func Permutations2[T any](in <-chan T) <-chan atuple.Packed2[T, T] {
	out := make(chan atuple.Packed2[T, T])

	go func() {
		defer close(out)
		permLen := 2 // number of elements in each permutation
		s := Slice(in)
		n := len(s)
		if n < permLen {
			panic("invalid argument to Permutations2: size of in must greater than or equal to 2")
		}
		indices := Slice(Range(n))
		out <- atuple.Pack2(s[indices[0]], s[indices[1]])
		cycles := Slice(RangeStep(n, n-permLen, -1))

		for {
			// based on Python's itertool:
			// https://github.com/python/cpython/blob/70c16468deee9390e34322d32fda57df6e0f46bb/Modules/itertoolsmodule.c#L3408
			// TODO: Find the name of the algorithm and update the variable names etc.
			var i int
			// Decrement rightmost cycle, moving leftward upon zero rollover
			for i = permLen - 1; i >= 0; i-- {
				cycles[i]--
				if cycles[i] == 0 {
					if i == 0 {
						return
					}

					// Move index at i to the end, shifting indices from i+1:end
					// forward by 1.
					indexI := indices[i]
					for j := i; j < n-1; j++ {
						indices[j] = indices[j+1]
					}
					indices[n-1] = indexI

					cycles[i] = n - i
				} else {
					j := cycles[i]
					indices[i], indices[n-j] = indices[n-j], indices[i]
					out <- atuple.Pack2(s[indices[0]], s[indices[1]])
					break
				}
			}
			// If i is negative, then the cycles have all rolled-over and we're done.
			if i < 0 {
				return
			}
		}
	}()

	return out
}

// Permutations3 is the 3-element version of Permutations.
func Permutations3[T any](in <-chan T) <-chan atuple.Packed3[T, T, T] {
	out := make(chan atuple.Packed3[T, T, T])

	go func() {
		defer close(out)
		permLen := 3 // number of elements in each permutation
		s := Slice(in)
		n := len(s)
		if n < permLen {
			panic("invalid argument to Permutations3: size of in must greater than or equal to 3")
		}
		indices := Slice(Range(n))
		out <- atuple.Pack3(s[indices[0]], s[indices[1]], s[indices[2]])
		cycles := Slice(RangeStep(n, n-permLen, -1))

		for {
			// based on Python's itertool:
			// https://github.com/python/cpython/blob/70c16468deee9390e34322d32fda57df6e0f46bb/Modules/itertoolsmodule.c#L3408
			// TODO: Find the name of the algorithm and update the variable names etc.
			var i int
			// Decrement rightmost cycle, moving leftward upon zero rollover
			for i = permLen - 1; i >= 0; i-- {
				cycles[i]--
				if cycles[i] == 0 {
					if i == 0 {
						return
					}

					// Move index at i to the end, shifting indices from i+1:end
					// forward by 1.
					indexI := indices[i]
					for j := i; j < n-1; j++ {
						indices[j] = indices[j+1]
					}
					indices[n-1] = indexI

					cycles[i] = n - i
				} else {
					j := cycles[i]
					indices[i], indices[n-j] = indices[n-j], indices[i]
					out <- atuple.Pack3(s[indices[0]], s[indices[1]], s[indices[2]])
					break
				}
			}
			// If i is negative, then the cycles have all rolled-over and we're done.
			if i < 0 {
				return
			}
		}
	}()

	return out
}

// Permutations4 is the 4-element version of Permutations.
func Permutations4[T any](in <-chan T) <-chan atuple.Packed4[T, T, T, T] {
	out := make(chan atuple.Packed4[T, T, T, T])

	go func() {
		defer close(out)
		permLen := 4 // number of elements in each permutation
		s := Slice(in)
		n := len(s)
		if n < permLen {
			panic("invalid argument to Permutations4: size of in must greater than or equal to 4")
		}
		indices := Slice(Range(n))
		out <- atuple.Pack4(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]])
		cycles := Slice(RangeStep(n, n-permLen, -1))

		for {
			// based on Python's itertool:
			// https://github.com/python/cpython/blob/70c16468deee9390e34322d32fda57df6e0f46bb/Modules/itertoolsmodule.c#L3408
			// TODO: Find the name of the algorithm and update the variable names etc.
			var i int
			// Decrement rightmost cycle, moving leftward upon zero rollover
			for i = permLen - 1; i >= 0; i-- {
				cycles[i]--
				if cycles[i] == 0 {
					if i == 0 {
						return
					}

					// Move index at i to the end, shifting indices from i+1:end
					// forward by 1.
					indexI := indices[i]
					for j := i; j < n-1; j++ {
						indices[j] = indices[j+1]
					}
					indices[n-1] = indexI

					cycles[i] = n - i
				} else {
					j := cycles[i]
					indices[i], indices[n-j] = indices[n-j], indices[i]
					out <- atuple.Pack4(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]])
					break
				}
			}
			// If i is negative, then the cycles have all rolled-over and we're done.
			if i < 0 {
				return
			}
		}
	}()

	return out
}

// Permutations5 is the 5-element version of Permutations.
func Permutations5[T any](in <-chan T) <-chan atuple.Packed5[T, T, T, T, T] {
	out := make(chan atuple.Packed5[T, T, T, T, T])

	go func() {
		defer close(out)
		permLen := 5 // number of elements in each permutation
		s := Slice(in)
		n := len(s)
		if n < permLen {
			panic("invalid argument to Permutations5: size of in must greater than or equal to 5")
		}
		indices := Slice(Range(n))
		out <- atuple.Pack5(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]])
		cycles := Slice(RangeStep(n, n-permLen, -1))

		for {
			// based on Python's itertool:
			// https://github.com/python/cpython/blob/70c16468deee9390e34322d32fda57df6e0f46bb/Modules/itertoolsmodule.c#L3408
			// TODO: Find the name of the algorithm and update the variable names etc.
			var i int
			// Decrement rightmost cycle, moving leftward upon zero rollover
			for i = permLen - 1; i >= 0; i-- {
				cycles[i]--
				if cycles[i] == 0 {
					if i == 0 {
						return
					}

					// Move index at i to the end, shifting indices from i+1:end
					// forward by 1.
					indexI := indices[i]
					for j := i; j < n-1; j++ {
						indices[j] = indices[j+1]
					}
					indices[n-1] = indexI

					cycles[i] = n - i
				} else {
					j := cycles[i]
					indices[i], indices[n-j] = indices[n-j], indices[i]
					out <- atuple.Pack5(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]])
					break
				}
			}
			// If i is negative, then the cycles have all rolled-over and we're done.
			if i < 0 {
				return
			}
		}
	}()

	return out
}

// Permutations6 is the 6-element version of Permutations.
func Permutations6[T any](in <-chan T) <-chan atuple.Packed6[T, T, T, T, T, T] {
	out := make(chan atuple.Packed6[T, T, T, T, T, T])

	go func() {
		defer close(out)
		permLen := 6 // number of elements in each permutation
		s := Slice(in)
		n := len(s)
		if n < permLen {
			panic("invalid argument to Permutations6: size of in must greater than or equal to 6")
		}
		indices := Slice(Range(n))
		out <- atuple.Pack6(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]])
		cycles := Slice(RangeStep(n, n-permLen, -1))

		for {
			// based on Python's itertool:
			// https://github.com/python/cpython/blob/70c16468deee9390e34322d32fda57df6e0f46bb/Modules/itertoolsmodule.c#L3408
			// TODO: Find the name of the algorithm and update the variable names etc.
			var i int
			// Decrement rightmost cycle, moving leftward upon zero rollover
			for i = permLen - 1; i >= 0; i-- {
				cycles[i]--
				if cycles[i] == 0 {
					if i == 0 {
						return
					}

					// Move index at i to the end, shifting indices from i+1:end
					// forward by 1.
					indexI := indices[i]
					for j := i; j < n-1; j++ {
						indices[j] = indices[j+1]
					}
					indices[n-1] = indexI

					cycles[i] = n - i
				} else {
					j := cycles[i]
					indices[i], indices[n-j] = indices[n-j], indices[i]
					out <- atuple.Pack6(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]])
					break
				}
			}
			// If i is negative, then the cycles have all rolled-over and we're done.
			if i < 0 {
				return
			}
		}
	}()

	return out
}

// Permutations7 is the 7-element version of Permutations.
func Permutations7[T any](in <-chan T) <-chan atuple.Packed7[T, T, T, T, T, T, T] {
	out := make(chan atuple.Packed7[T, T, T, T, T, T, T])

	go func() {
		defer close(out)
		permLen := 7 // number of elements in each permutation
		s := Slice(in)
		n := len(s)
		if n < permLen {
			panic("invalid argument to Permutations7: size of in must greater than or equal to 7")
		}
		indices := Slice(Range(n))
		out <- atuple.Pack7(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]], s[indices[6]])
		cycles := Slice(RangeStep(n, n-permLen, -1))

		for {
			// based on Python's itertool:
			// https://github.com/python/cpython/blob/70c16468deee9390e34322d32fda57df6e0f46bb/Modules/itertoolsmodule.c#L3408
			// TODO: Find the name of the algorithm and update the variable names etc.
			var i int
			// Decrement rightmost cycle, moving leftward upon zero rollover
			for i = permLen - 1; i >= 0; i-- {
				cycles[i]--
				if cycles[i] == 0 {
					if i == 0 {
						return
					}

					// Move index at i to the end, shifting indices from i+1:end
					// forward by 1.
					indexI := indices[i]
					for j := i; j < n-1; j++ {
						indices[j] = indices[j+1]
					}
					indices[n-1] = indexI

					cycles[i] = n - i
				} else {
					j := cycles[i]
					indices[i], indices[n-j] = indices[n-j], indices[i]
					out <- atuple.Pack7(s[indices[0]], s[indices[1]], s[indices[2]], s[indices[3]], s[indices[4]], s[indices[5]], s[indices[6]])
					break
				}
			}
			// If i is negative, then the cycles have all rolled-over and we're done.
			if i < 0 {
				return
			}
		}
	}()

	return out
}
